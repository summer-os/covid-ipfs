{"ast":null,"code":"import { useEffect, useRef } from 'react';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar getCircularReplacer = function getCircularReplacer() {\n  var seen = new WeakSet();\n  return function (key, value) {\n    if (_typeof(value) === 'object' && value !== null) {\n      if (seen.has(value)) {\n        return;\n      }\n\n      seen.add(value);\n    }\n\n    return value;\n  };\n};\n/**\r\n * 一个更加安全的 stringify，可以解决循环依赖的问题\r\n * @param value\r\n */\n\n\nvar stringify = function stringify(value) {\n  return JSON.stringify(value, getCircularReplacer());\n};\n\nvar jsonCompareEquals = function jsonCompareEquals(value, nextValue) {\n  try {\n    return stringify(value) === stringify(nextValue);\n  } catch (error) {// do something\n  }\n\n  return false;\n};\n\nfunction useJsonCompareMemoize(value) {\n  var ref = useRef(''); // it can be done by using useMemo as well\n  // but useRef is rather cleaner and easier\n\n  if (!jsonCompareEquals(value, ref.current)) {\n    ref.current = JSON.stringify(value, getCircularReplacer());\n  }\n\n  return ref.current;\n}\n\nfunction useDeepJSONEffect(effect, dependencies) {\n  useEffect(effect, [useJsonCompareMemoize(dependencies)]);\n}\n\nexport default useDeepJSONEffect;\nexport { stringify };","map":{"version":3,"sources":["/Users/jameszow/Documents/RustWorkSpace/covid-ipfs/covid-ipfs-client/node_modules/use-json-comparison/dist/index.esm.js"],"names":["useEffect","useRef","_typeof","obj","Symbol","iterator","constructor","prototype","getCircularReplacer","seen","WeakSet","key","value","has","add","stringify","JSON","jsonCompareEquals","nextValue","error","useJsonCompareMemoize","ref","current","useDeepJSONEffect","effect","dependencies"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;;AAEA,SAASC,OAAT,CAAiBC,GAAjB,EAAsB;AACpB;;AAEA,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA/D,EAAyE;AACvEH,IAAAA,OAAO,GAAG,iBAAUC,GAAV,EAAe;AACvB,aAAO,OAAOA,GAAd;AACD,KAFD;AAGD,GAJD,MAIO;AACLD,IAAAA,OAAO,GAAG,iBAAUC,GAAV,EAAe;AACvB,aAAOA,GAAG,IAAI,OAAOC,MAAP,KAAkB,UAAzB,IAAuCD,GAAG,CAACG,WAAJ,KAAoBF,MAA3D,IAAqED,GAAG,KAAKC,MAAM,CAACG,SAApF,GAAgG,QAAhG,GAA2G,OAAOJ,GAAzH;AACD,KAFD;AAGD;;AAED,SAAOD,OAAO,CAACC,GAAD,CAAd;AACD;;AAED,IAAIK,mBAAmB,GAAG,SAASA,mBAAT,GAA+B;AACvD,MAAIC,IAAI,GAAG,IAAIC,OAAJ,EAAX;AACA,SAAO,UAAUC,GAAV,EAAeC,KAAf,EAAsB;AAC3B,QAAIV,OAAO,CAACU,KAAD,CAAP,KAAmB,QAAnB,IAA+BA,KAAK,KAAK,IAA7C,EAAmD;AACjD,UAAIH,IAAI,CAACI,GAAL,CAASD,KAAT,CAAJ,EAAqB;AACnB;AACD;;AAEDH,MAAAA,IAAI,CAACK,GAAL,CAASF,KAAT;AACD;;AAED,WAAOA,KAAP;AACD,GAVD;AAWD,CAbD;AAcA;AACA;AACA;AACA;;;AAGA,IAAIG,SAAS,GAAG,SAASA,SAAT,CAAmBH,KAAnB,EAA0B;AACxC,SAAOI,IAAI,CAACD,SAAL,CAAeH,KAAf,EAAsBJ,mBAAmB,EAAzC,CAAP;AACD,CAFD;;AAIA,IAAIS,iBAAiB,GAAG,SAASA,iBAAT,CAA2BL,KAA3B,EAAkCM,SAAlC,EAA6C;AACnE,MAAI;AACF,WAAOH,SAAS,CAACH,KAAD,CAAT,KAAqBG,SAAS,CAACG,SAAD,CAArC;AACD,GAFD,CAEE,OAAOC,KAAP,EAAc,CAAC;AAChB;;AAED,SAAO,KAAP;AACD,CAPD;;AASA,SAASC,qBAAT,CAA+BR,KAA/B,EAAsC;AACpC,MAAIS,GAAG,GAAGpB,MAAM,CAAC,EAAD,CAAhB,CADoC,CACd;AACtB;;AAEA,MAAI,CAACgB,iBAAiB,CAACL,KAAD,EAAQS,GAAG,CAACC,OAAZ,CAAtB,EAA4C;AAC1CD,IAAAA,GAAG,CAACC,OAAJ,GAAcN,IAAI,CAACD,SAAL,CAAeH,KAAf,EAAsBJ,mBAAmB,EAAzC,CAAd;AACD;;AAED,SAAOa,GAAG,CAACC,OAAX;AACD;;AACD,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,YAAnC,EAAiD;AAC/CzB,EAAAA,SAAS,CAACwB,MAAD,EAAS,CAACJ,qBAAqB,CAACK,YAAD,CAAtB,CAAT,CAAT;AACD;;AAED,eAAeF,iBAAf;AACA,SAASR,SAAT","sourcesContent":["import { useEffect, useRef } from 'react';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar getCircularReplacer = function getCircularReplacer() {\n  var seen = new WeakSet();\n  return function (key, value) {\n    if (_typeof(value) === 'object' && value !== null) {\n      if (seen.has(value)) {\n        return;\n      }\n\n      seen.add(value);\n    }\n\n    return value;\n  };\n};\n/**\r\n * 一个更加安全的 stringify，可以解决循环依赖的问题\r\n * @param value\r\n */\n\n\nvar stringify = function stringify(value) {\n  return JSON.stringify(value, getCircularReplacer());\n};\n\nvar jsonCompareEquals = function jsonCompareEquals(value, nextValue) {\n  try {\n    return stringify(value) === stringify(nextValue);\n  } catch (error) {// do something\n  }\n\n  return false;\n};\n\nfunction useJsonCompareMemoize(value) {\n  var ref = useRef(''); // it can be done by using useMemo as well\n  // but useRef is rather cleaner and easier\n\n  if (!jsonCompareEquals(value, ref.current)) {\n    ref.current = JSON.stringify(value, getCircularReplacer());\n  }\n\n  return ref.current;\n}\nfunction useDeepJSONEffect(effect, dependencies) {\n  useEffect(effect, [useJsonCompareMemoize(dependencies)]);\n}\n\nexport default useDeepJSONEffect;\nexport { stringify };\n"]},"metadata":{},"sourceType":"module"}